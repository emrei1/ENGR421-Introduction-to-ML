# -*- coding: utf-8 -*-
"""engr421hw9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gvOAvJMQgu_txceo5Q2NlTv4hDcsB-J2
"""

# import packages
import numpy as np
import matplotlib.pyplot as plt
import scipy.spatial as spa
import scipy as sp

# import data
data_set = np.genfromtxt("hw09_data_set.csv", delimiter = ",")

# retrieve B matrix
delta = 2.0
B = np.zeros((len(data_set[:, 0]), len(data_set[:, 0])))

for i in range(len(B[:, 0])):
  for j in range(len(B[0, :])):
    if i == j:
      B[i, j] = 0
    else:
      x1 = data_set[i]
      x2 = data_set[j]
      dist = np.linalg.norm(x1 - x2)
      if dist < delta:
        B[i, j] = 1

# retrieve D matrix 

D = np.zeros((len(data_set[:, 0]), len(data_set[:, 0])))

for i in range(len(data_set[:, 0])):
  for j in range(len(data_set[:, 0])):
    if i == j:
      sum = np.sum(B[i])
      D[i, j] = sum

# plot data and point connections based on the B matrix

plt.figure(figsize = (8, 8))
plt.xlim(-8, 8)
plt.ylim(-8, 8)
plt.xlabel("x1")
plt.ylabel("x2")

for i in range(len(data_set[:, 0])):
  for j in range(len(data_set[:, 0])):
    if B[i, j] != 0:
      first = data_set[i]
      second = data_set[j]
      plt.plot([first[0], second[0]], [first[1], second[1]], "k-", color = "gray")

for i in range(len(data_set[:, 0])):
  xi = data_set[i]
  plt.plot(xi[0], xi[1], marker = 'o', linestyle = "none", color = "black", markersize = 4)

# retrieve the L_symmetric matrix

I = np.identity(len(data_set[:, 0]))
D_neg_half_power = sp.linalg.fractional_matrix_power(D, -0.5)

L_symmetric = I - np.matmul(np.matmul(D_neg_half_power, B), D_neg_half_power)

print("L_symmetric[0:5, 0:5]:")
print(L_symmetric[0:5, 0:5])

# find R smallest eigenvectors of L_symmetric matrix

R = 5

eigenvalues, eigenvectors = np.linalg.eig(L_symmetric)
eigenvectors = eigenvectors.T
Z = eigenvectors[np.argsort(eigenvalues)[1 : (R + 1)]].T

print("Z[0:5, 0:5]:")
print(Z[0:5, 0:5])

def update_centroids(memberships, X, N, K, R):
    if memberships is None:
        # initialize centroids for assuming K = 9 based on the row numbers defined in spec
        centroids = np.zeros((K, R))
        centroids[0] = X[242]
        centroids[1] = X[528]
        centroids[2] = X[570]
        centroids[3] = X[590]
        centroids[4] = X[648]
        centroids[5] = X[667]
        centroids[6] = X[774]
        centroids[7] = X[891]
        centroids[8] = X[955]
    else:
        # update centroids
        centroids = np.vstack([np.mean(X[memberships == k,:], axis = 0) for k in range(K)])
    return centroids

def update_memberships(centroids, X):
    # calculate distances between centroids and data points
    D = spa.distance_matrix(centroids, X)
    # find the nearest centroid for each data point
    memberships = np.argmin(D, axis = 0)

    return memberships

# iterate over the learning algorithm to finalize class labels and final centroids
centroids = None
memberships = None
iteration = 0
K = 9
N = len(data_set)
while True:
    iteration += 1
    old_centroids = centroids
    centroids = update_centroids(memberships, Z, N, K, R)
    if np.alltrue(centroids == old_centroids):
        break

    old_memberships = memberships
    memberships = update_memberships(centroids, Z)
    if np.alltrue(memberships == old_memberships):
        break

centroids = update_centroids(memberships, data_set, N, K, R)

print("algorithm finished")
print("number of iterations: " + str(iteration))

# plot final data
plt.figure(figsize = (10, 10)) 
plt.xlim(-8, 8)
plt.ylim(-8, 8)
cluster_colors = np.array(["#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", "#b15928",
                            "#a6cee3", "#b2df8a", "#fb9a99", "#fdbf6f", "#cab2d6", "#ffff99"])

for c in range(K):
        plt.plot(data_set[memberships == c, 0], data_set[memberships == c, 1], ".", markersize = 10,
                  color = cluster_colors[c])
for c in range(K):
   plt.plot(centroids[c, 0], centroids[c, 1], "s", markersize = 12, 
              markerfacecolor = cluster_colors[c], markeredgecolor = "black")
   
plt.xlabel("x1")
plt.ylabel("x2")